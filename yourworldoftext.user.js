// ==UserScript==
// @name         WorldSaver
// @namespace    https://github.com/qmhQTqiGh8AGfqYkNyP7/WorldSaver
// @icon         http://www.yourworldoftext.com/static/favicon.png
// @version      0.1
// @description  Allows to save yourworldoftext.com worlds as raw HTML
// @author       Nipah~
// @match        http://www.yourworldoftext.com/*
// @match        https://www.yourworldoftext.com/*
// @grant        none
// @run-at       document-end
// ==/UserScript==


/* jshint strict: true */
/* jshint esversion: 6 */

(function () {
    'use strict';

    const VERSION = '0.1';
    const CHUNK_TILES_X = 20;  // number of tiles in one request
    const CHUNK_TILES_Y = 20;  // number of tiles in one request
    const TILE_ROWS = 8;  // number of letters
    const TILE_COLS = 16;  // number of letters
    const TILE_WIDTH = 160;  // in pixels
    const TILE_HEIGHT = 144;  // in pixels
    const  HTML_TEMPLATE = [
`<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WorldSaver</title>
    <style type="text/css">
    * {
        margin: 0;
        padding: 0;
    }
    #container {
        font-family: 'Courier New';
        white-space: pre;
        line-height: 18px;
        letter-spacing: 0.4px;
    }
    .dark {
        color: white;
        background-color: black;
    }
    .tile {
        position: absolute;
        overflow: hidden;
        width: 160px;
        height: 144px;
    }
    .tile table {
        line-height: 18px;
        table-layout: fixed;
    }
    .tile table tr {
        height: 18px;
    }
    </style>
</head>
<body>
    <!-- Autogenerated with WorldSaver userscript. Nipah~ -->
    <div id="meta" style="display: none;">
        <div id="meta_url"></div>
        <div id="meta_date"></div>
        <div id="meta_version"></div>
        <div id="meta_settings"></div>
        <div id="meta_source"></div>
    </div>
    <div id="container">
        <div id="loading">Loading...</div>
        <div id="progress">0%</div>
    </div>
</body>
</html>`
];


    class Chunk {
        //  Chunk represents range of Tiles in one request
        constructor(min_tileX, min_tileY, max_tileX, max_tileY) {
            this.min_tileX = min_tileX;  // top left corner
            this.min_tileY = min_tileY;  // top left corner
            this.max_tileX = max_tileX;  // bottom right corner
            this.max_tileY = max_tileY;  // bottom right corner
            this.x = Math.floor(min_tileX / CHUNK_TILES_X);
            this.y = Math.floor(min_tileY / CHUNK_TILES_Y);
        }

        static fromPoint(point) {
            const x = point.x * CHUNK_TILES_X;
            const y = point.y * CHUNK_TILES_Y;
            return new Chunk(x, y, (x + CHUNK_TILES_X - 1), (y + CHUNK_TILES_Y - 1));
        }

        get tilesX() {
            return this.max_tileX - this.min_tileX;
        }

        get tilesY() {
            return this.max_tileY - this.min_tileY;
        }

        toString() {
            return [this.min_tileY, this.min_tileX].join(';');
        }
    }


    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        toString() {
            return [this.y, this.x].join(';');
        }
    }


    class Tile extends Point {
        // Tile contains 8 rows of 16 letters each
        constructor(x, y, content, properties) {
            super(x, y);
            this.content = content;
            this.properties = properties;
        }

        static fromTileData(tileKey, tileObj) {
            if (!tileObj || !tileObj.content || !/\S/.test(tileObj.content)) {
                return null;
            }
            const coords = tileKey.split(',');
            const y = parseInt(coords[0], 10);
            const x = parseInt(coords[1], 10);
            return new Tile(x, y, tileObj.content, tileObj.properties);
        }

        get isEmpty() {
            return !this.content || !/\S/.test(this.content);
        }
    }


    var settings = {
        min_tileX: -1,
        min_tileY: -1,
        max_tileX: 1,
        max_tileY: 1,
        N: 1
    };
    // Permissions.can_paste = function() {return true;};
    // Permissions.can_go_to_coord = function(user, world) {return true;};

    function fillTileDiv_plain(tileDiv, chars) {
        var content = '';
        // separate string to lines
        for (var i = 0; i < TILE_ROWS; i++) {
            for (var j = 0; j < TILE_COLS; j++) {
                var c = chars[i * TILE_COLS + j];
                if (c) {
                    content += c;
                }
            }
            if (i < TILE_ROWS - 1) {
                content += '\n';
            }
        }
        tileDiv.innerText = content;
    }

    // VERY slow
    function fillTileDiv_table(tileDiv, chars) {
        tileDiv.insertAdjacentHTML('afterbegin',
            `<table width="100%" cellspacing="0" cellpadding="0" border="0">
                <tbody></tbody>
            </table>`
        );

        const tbody = tileDiv.querySelector('tbody');
        var content = '';
        // separate string to lines
        for (var i = 0; i < TILE_ROWS; i++) {
            var tr = document.createElement('tr');
            for (var j = 0; j < TILE_COLS; j++) {
                var td = document.createElement('td');
                var c = chars[i * TILE_COLS + j];
                if (c) {
                    td.innerText = c;
                }
                tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }
    }


    function createTileDiv(tile, worldBorders) {
        const tileDiv = document.createElement('div');
        tileDiv.className = 'tile';
        tileDiv.title = tile.toString();
        const y = tile.y - worldBorders.min_tileY;
        const x = tile.x - worldBorders.min_tileX;
        tileDiv.style.left = (x * TILE_WIDTH) + 'px';
        tileDiv.style.top = (y * (TILE_HEIGHT - 1)) + 'px';
        fillTileDiv_plain(tileDiv, tile.content.split(''));
        // fillTileDiv_table(tileDiv, tile.content.split(''));
        return tileDiv;
    }


    function make_chunks(minX, minY, maxX, maxY) {
        var chunks = [];
        for (var x = minX; x <= maxX; x++) {
            for (var y = minY; y <= maxY; y++) {
                chunks.push(Chunk.fromPoint(new Point(x, y)));
            }
        }
        return chunks;
    }


    function createGui() {
        // create button
        document.querySelector('#nav ul').insertAdjacentHTML('beforeend',
            `<li>
                <div id="ywscript-btn">Save this world</div>
            </li>`);
    }


    function createHtmlDoc() {
        var newWindow = window.open();
        var doc = newWindow.document;
        doc.write(HTML_TEMPLATE);
        // Dollchan-Extension-Tools copypasta
        var d = new Date(),
            fn = function fn(i) {
            return parseInt(i) < 10 ? '0' + i : i;
        };
        var roomName = window.location.pathname.replace('/', '');
        roomName = roomName ? roomName + '_' : '';
        doc.title = 'yourworldoftext_' + roomName + d.getFullYear() + fn(d.getMonth() + 1) + fn(d.getDate()) + '_' + fn(d.getHours()) + fn(d.getMinutes());
        // </copypasta>
        doc.querySelector('#meta_url').innerText = window.location.origin;
        doc.querySelector('#meta_date').innerText = d.toISOString();
        doc.querySelector('#meta_version').innerText = VERSION;
        doc.querySelector('#meta_settings').innerText = JSON.stringify(settings);
        return doc;
    }


    function makeXMLHttpPromise(chunk, resolve, reject) {
        let promise = new Promise(function(resolve, reject) {
            var request = new XMLHttpRequest();
            let url = window.location.pathname + '?fetch=1';
            url += '&min_tileY=' + chunk.min_tileY;
            url += '&min_tileX=' + chunk.min_tileX;
            url += '&max_tileY=' + chunk.max_tileY;
            url += '&max_tileX=' + chunk.max_tileX;
            url += '&v=3';
            request.open('GET', url);
            request.send(null);

            request.onload = function() {
                if (request.readyState === XMLHttpRequest.DONE) {
                    resolve(request.response);
                } else {
                    reject(request.statusText);
                }
            };
            request.onerror = function() {
                reject(request.statusText);
            };
        });

        return promise;
    }


    var getWebSocket = (function() {
        let ws_scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        let path = window.location.pathname.replace(/\/$/, '');
        let ws_path = ws_scheme + "://" + window.location.host + path + "/ws/";
        var socket = new WebSocket(ws_path);
        return function() {
            return socket;
        };
    })();


    function makeWebSocketPromise(chunk, resolve, reject) {
        return new Promise(function(resolve, reject) {
            let socket = getWebSocket();

            socket.onmessage = function(event) {
                let data = JSON.parse(event.data);
                if (data.kind === 'fetch') {
                    resolve(data.tiles);
                }
            };

            socket.onclose = function(event) {
                reject(event.reason);
            };

            let data = {
                kind: "fetch",
                min_tileY: chunk.min_tileY,
                min_tileX: chunk.min_tileX,
                max_tileY: chunk.max_tileY,
                max_tileX: chunk.max_tileX,
                v: 3
            };
            socket.send(JSON.stringify(data));
        });
    }


    function requestForChunk(chunk, resolve, reject) {
        return makeWebSocketPromise(chunk, resolve, reject);
        // return makeXMLHttpPromise(chunk, resolve, reject);
    }


    createGui();
    document.querySelector('#ywscript-btn').addEventListener('click', function(event) {
        var doc = createHtmlDoc();
        var processedChunks = {};  // dictionary with coordinates
        var processingQueue = [];  // array of Chunk instances
        var recievedTiles = [];  // array of Tile instances
        var map = {};
        var worldBorders = {};
        // processingQueue = make_chunks(settings.min_tileX, settings.min_tileY, settings.max_tileX, settings.max_tileY);
        // var totalRanges = processingQueue.length;

        function processResponse(tiles) {
            let notEmpty = false;
            for (let tileKey in tiles) {
                let tileObj = tiles[tileKey];
                let tile = Tile.fromTileData(tileKey, tileObj);
                if (!tile) {
                    continue;
                }
                notEmpty = true;
                map[tileKey] = tileObj;
                recievedTiles.push(tile);
                if (worldBorders.min_tileX === undefined) {
                    worldBorders.min_tileX = tile.x;
                    worldBorders.min_tileY = tile.y;
                    worldBorders.max_tileX = tile.x;
                    worldBorders.max_tileY = tile.y;
                } else {
                    worldBorders.min_tileX = Math.min(worldBorders.min_tileX, tile.x);
                    worldBorders.min_tileY = Math.min(worldBorders.min_tileY, tile.y);
                    worldBorders.max_tileX = Math.max(worldBorders.max_tileX, tile.x);
                    worldBorders.max_tileY = Math.max(worldBorders.max_tileY, tile.y);
                }
            }
            doc.body.querySelector('#progress').innerText = recievedTiles.length;
            return notEmpty;
        }

        // Yuki N.
        function processNeighbours(chunk, queue, N) {
            var searchAreaLeftBound = chunk.x - N - 1;
            var searchAreaRightBound = chunk.x + N + 1;
            var searchAreaUpperBound = chunk.y - N - 1;
            var searchAreaLowerBound = chunk.y + N + 1;
            for (var pX = searchAreaLeftBound; pX <= searchAreaRightBound; pX++) {
                for(var pY = searchAreaUpperBound; pY <= searchAreaLowerBound; pY++) {
                    var potentialChunk = Chunk.fromPoint(new Point(pX, pY));
                    if (!processedChunks[potentialChunk.toString()]) {
                        queue.push(potentialChunk);
                    }
                }
            }
        }


        function getNonEmptyChunks(chunk, onFinish) {
            requestForChunk(chunk)
                .then(function(response) {
                    let notEmpty = processResponse(response);
                    processedChunks[chunk.toString()] = true;
                    if (notEmpty) {
                        processNeighbours(chunk, processingQueue, settings.N);
                    }
                    // doc.body.querySelector('#progress').innerText = Math.floor((100 * (totalRanges - processingQueue.length)) / totalRanges) + '%';
                    if (processingQueue.length > 0) {
                        getNonEmptyChunks(processingQueue.pop(), onFinish);
                    } else {
                        onFinish();
                    }
                });
        }

        processingQueue.push(Chunk.fromPoint(new Point(0, 0)));
        getNonEmptyChunks(processingQueue.pop(), function() {
            doc.body.querySelector('#container').innerHTML = '';
            doc.querySelector('#meta_source').innerText = JSON.stringify(map);

            for (var i = 0; i < recievedTiles.length; i++) {
                var currentTile = recievedTiles[i];
                var tileDiv = createTileDiv(currentTile, worldBorders);
                doc.body.querySelector('#container').appendChild(tileDiv);
            }
        });
    });

    console.log('WorldSaver ready');

})();
